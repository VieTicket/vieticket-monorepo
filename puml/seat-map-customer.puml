@startuml customer-seat-selection
!theme plain
title Customer Seat Selection Flow

actor Customer
participant "UI Component" as UI
participant "Canvas Component" as Canvas
participant "State Provider" as State
participant "API Actions" as Actions
participant "Event Service" as EventService
participant "Ticket Service" as TicketService
participant "SeatMap Service" as SeatMapService
participant "MongoDB" as MongoDB
participant "PostgreSQL" as PostgresDB

Customer -> UI: Click "Buy Tickets" on event
UI -> UI: Navigate to /events/{id}/tickets

UI -> Actions: loadEventWithSeatingAction(eventId)
activate Actions
Actions -> EventService: getEventWithSeating(eventId)
Actions -> MongoDB: Query event with areas/rows/seats
MongoDB --> Actions: Event with seating structure

alt Event has seat map
    Actions -> SeatMapService: getSeatMapById(seatMapId)
    Actions -> MongoDB: Query seat map shapes
    MongoDB --> Actions: Seat map with shapes
else No seat map
    Actions --> UI: Error: No seat map configured
end

Actions --> UI: Event + seat map + seating structure
deactivate Actions

UI -> Actions: getTicketAvailabilityAction(eventId)
activate Actions
Actions -> TicketService: getTicketAvailability(eventId)
Actions -> PostgresDB: Query tickets table for sold/held seats
PostgresDB --> Actions: Availability data by seat
Actions --> UI: Seat availability status
deactivate Actions

UI -> Canvas: Render with seatMapData + seatingStructure
Canvas -> State: Initialize stage
Canvas -> Canvas: enhanceShapesWithSeatingData()

Note right of Canvas
  Enhanced shapes include:
  - Seat IDs from seating structure
  - Availability status (available/sold/held)
  - Pricing information
  - Visual styling based on status
end note

Customer -> Canvas: Pan and zoom to explore seating
Canvas -> Canvas: handleWheel() / handleMouseMove()

Customer -> Canvas: Click on available seat
Canvas -> UI: onSeatClick(seatId, isAvailable)

alt Seat is available
    UI -> UI: addSeatToSelection(seatId)
    UI -> Canvas: Re-render with updated selectedSeats
    Canvas -> Canvas: Update seat visual (blue = selected)
else Seat unavailable
    UI -> UI: toast.error("Seat not available")
end

loop Customer selects multiple seats
    Customer -> Canvas: Click additional seats
    Canvas -> UI: onSeatClick(seatId, isAvailable)
    UI -> UI: toggleSeatSelection(seatId)
    UI -> Canvas: Update selectedSeats array
end

Customer -> UI: Review selected seats in sidebar
UI -> UI: calculateTotalPrice()

Customer -> UI: Click "Continue to Checkout"
UI -> UI: validateSeatSelection()
UI -> Customer: Navigate to checkout page with selected seats

@enduml

@startuml seat-availability-management
!theme plain
title Real-time Seat Availability Management

participant "Customer A Browser" as CustomerA
participant "Customer B Browser" as CustomerB
participant "UI Component" as UI
participant "API Actions" as Actions
participant "Ticket Service" as Service
participant "Redis Cache" as Redis
participant "PostgreSQL" as DB
participant "Real-time Service" as RealTime

== Initial Load ==
CustomerA -> UI: Load event ticket page
UI -> Service: getTicketAvailability(eventId)
Service -> DB: Query current ticket status
DB --> Service: Seat availability data
Service --> UI: Current availability

CustomerB -> UI: Load same event (different session)
UI -> Service: getTicketAvailability(eventId)
Service --> UI: Same availability data

== Seat Selection & Holding ==
CustomerA -> UI: Select seat A1
UI -> Actions: holdSeatsAction([seatA1], sessionId)
activate Actions

Actions -> Service: holdSeats(eventId, seatIds, customerId, sessionId)
Service -> DB: BEGIN TRANSACTION
Service -> DB: SELECT seats FOR UPDATE
DB --> Service: Current seat statuses

alt Seats still available
    Service -> DB: UPDATE seats SET status='held', heldBy=customerId, heldUntil=now()+15min
    Service -> Redis: SET seat_hold:{seatId} = {customerId, expiry}
    DB --> Service: Seats held successfully
    Service -> DB: COMMIT
    
    Service -> RealTime: broadcast_seat_update(eventId, seatId, 'held')
    RealTime -> CustomerB: Seat A1 now held (visual update)
    
    Actions --> UI: Success - seats held
    UI -> UI: Start 15-minute countdown timer
else Seats already taken
    Service -> DB: ROLLBACK
    Actions --> UI: Error - seats no longer available
    UI -> UI: Remove from selection, show error
end
deactivate Actions

== Concurrent Selection Attempt ==
CustomerB -> UI: Try to select same seat A1
UI -> UI: getSeatStatus(A1) = 'held'
UI -> UI: Prevent selection, show "Held by another user"

== Hold Expiration ==
Redis -> Service: Seat hold expired (15 min timer)
Service -> DB: UPDATE seats SET status='available' WHERE heldUntil < now()
Service -> RealTime: broadcast_seat_update(eventId, seatId, 'available')
RealTime -> CustomerB: Seat A1 now available again

== Manual Release ==
CustomerA -> UI: Deselect seat or navigate away
UI -> Actions: releaseSeatsAction([seatA1], sessionId)
Actions -> Service: releaseSeats(eventId, seatIds, customerId)
Service -> DB: UPDATE seats SET status='available'
Service -> Redis: DEL seat_hold:{seatId}
Service -> RealTime: broadcast_seat_update(eventId, seatId, 'available')

@enduml

@startuml checkout-process
!theme plain
title Ticket Checkout Process

actor Customer
participant "UI Component" as UI
participant "Payment Component" as Payment
participant "API Actions" as Actions
participant "Order Service" as OrderService
participant "Payment Service" as PaymentService
participant "Ticket Service" as TicketService
participant "Email Service" as EmailService
participant "PostgreSQL" as DB
participant "Payment Gateway" as PaymentGW
participant "PDF Generator" as PDFGen

Customer -> UI: Click "Continue to Checkout"
UI -> UI: validateSelectedSeats()

alt No seats selected
    UI -> Customer: toast.error("Please select seats")
else Seats selected
    UI -> UI: Navigate to checkout page with selected seat data
end

UI -> UI: displayOrderSummary()
Note right of UI
  Order Summary:
  - Event details
  - Selected seats with pricing
  - Total amount
  - Customer information form
end note

Customer -> UI: Fill customer information
Customer -> UI: Select payment method
Customer -> Payment: Enter payment details

Customer -> UI: Click "Complete Purchase"
UI -> Actions: createOrderAction(orderData)
activate Actions

Actions -> OrderService: createOrder(eventId, customerId, seatIds, amount)
OrderService -> DB: BEGIN TRANSACTION

OrderService -> TicketService: validateSeatAvailability(seatIds)
TicketService -> DB: SELECT seats FOR UPDATE WHERE id IN (seatIds)

alt Seats still held by this customer
    OrderService -> DB: INSERT INTO orders (customer, event, amount, status='pending')
    OrderService -> DB: INSERT INTO order_items (order, seat, price)
    
    Actions --> UI: Order created successfully
    deactivate Actions
    
    UI -> Actions: processPaymentAction(orderId, paymentDetails)
    activate Actions
    
    Actions -> PaymentService: processPayment(orderId, amount, paymentMethod)
    PaymentService -> PaymentGW: charge(amount, paymentDetails)
    
    alt Payment successful
        PaymentGW --> PaymentService: Payment confirmed
        PaymentService -> DB: UPDATE orders SET status='paid', paymentId=xyz
        PaymentService -> DB: UPDATE seats SET status='sold', soldTo=customerId
        PaymentService -> DB: DELETE FROM seat_holds WHERE seatId IN (seatIds)
        PaymentService -> DB: COMMIT
        
        Actions --> UI: Payment successful
        deactivate Actions
        
        UI -> PDFGen: generateTickets(orderId)
        PDFGen -> DB: Query order details with seat info
        PDFGen --> UI: PDF ticket files
        
        UI -> EmailService: sendTickets(customerEmail, pdfFiles)
        EmailService -> Customer: Email with ticket attachments
        
        UI -> Customer: Show success page with download links
        
    else Payment failed
        PaymentGW --> PaymentService: Payment declined
        PaymentService -> DB: UPDATE orders SET status='failed'
        PaymentService -> DB: UPDATE seats SET status='available'
        PaymentService -> DB: COMMIT
        
        Actions --> UI: Payment failed
        UI -> Customer: Show error, return to payment
    end
    
else Seats no longer available
    OrderService -> DB: ROLLBACK
    Actions --> UI: Error - seats no longer available
    UI -> UI: Redirect back to seat selection
    UI -> Customer: toast.error("Selected seats are no longer available")
end

@enduml

@startuml seat-map-canvas-customer-interactions
!theme plain
title Seat Map Canvas Customer Interactions

actor Customer
participant "Canvas Component" as Canvas
participant "Stage Hook" as StageHook
participant "Rendering Engine" as Renderer
participant "Event Handlers" as Events
participant "UI Component" as UI

== Canvas Initialization ==
Customer -> Canvas: Component mounts
Canvas -> StageHook: Get stage reference
Canvas -> Canvas: Initialize viewport size
Canvas -> Canvas: enhanceShapesWithSeatingData()

Note right of Canvas
  Enhancement process:
  1. Match MongoDB shapes with PostgreSQL seating
  2. Add seat IDs, pricing, availability
  3. Apply visual styling based on status
  4. Create interactive seat elements
end Note

Canvas -> Renderer: Render enhanced shapes
Canvas -> Canvas: centerCanvasOnLoad()

== Visual Status Mapping ==
Canvas -> Canvas: getSeatFillColor(status, isSelected)

Note right of Canvas
  Status Colors:
  - available: #10b981 (emerald-500)
  - sold: #ef4444 (red-500) 
  - held: #f59e0b (amber-500)
  - selected: #3b82f6 (blue-500)
end note

== Customer Interactions ==
Customer -> Renderer: Pan canvas (mouse drag)
Renderer -> Events: handleMouseMove() + handleMouseDown/Up()
Events -> Canvas: updatePanPosition()

Customer -> Renderer: Zoom (mouse wheel)
Renderer -> Events: handleWheel()
Events -> Canvas: updateZoomAndPan()

Customer -> Renderer: Click on seat
Renderer -> Events: Route click to seat element
Events -> Canvas: handleSeatClick(seatId, seatData)

Canvas -> Canvas: Check seat availability
alt Seat is available
    Canvas -> UI: onSeatClick(seatId, true)
    UI -> UI: toggleSeatSelection(seatId)
    UI -> Canvas: Update selectedSeats array
    Canvas -> Canvas: Re-render with new selection
else Seat unavailable (sold/held)
    Canvas -> UI: onSeatClick(seatId, false)
    UI -> Customer: toast.error("Seat not available")
end

== Real-time Updates ==
loop Real-time availability changes
    UI -> Canvas: Updated availability data
    Canvas -> Canvas: Re-enhance shapes with new status
    Canvas -> Renderer: Re-render affected seats
    Renderer -> Customer: Visual update (color changes)
end

== Mobile Responsiveness ==
Customer -> Canvas: Touch interactions (mobile)
Canvas -> Renderer: Handle touch events
Renderer -> Events: Convert to pan/zoom/select operations

Note right of Canvas
  Mobile optimizations:
  - Touch-friendly seat sizes
  - Gesture-based pan/zoom
  - Accessible seat selection
  - Responsive layout adjustments
end note

@enduml

@startuml ticket-pricing-calculation
!theme plain
title Dynamic Ticket Pricing & Calculation

participant "UI Component" as UI
participant "Canvas Component" as Canvas
participant "API Actions" as Actions
participant "Pricing Service" as PricingService
participant "Event Service" as EventService
participant "PostgreSQL" as DB

== Initial Pricing Load ==
UI -> Actions: calculatePricingAction(eventId)
activate Actions
Actions -> PricingService: getEventPricing(eventId)
PricingService -> DB: Query event pricing rules
DB --> PricingService: Base prices, discounts, fees

alt Event has dynamic pricing
    PricingService -> DB: Query current demand/sales
    PricingService -> PricingService: calculateDynamicMultiplier()
else Fixed pricing
    PricingService -> PricingService: Use base prices
end

Actions --> UI: Pricing structure
deactivate Actions

UI -> Canvas: Display prices on seat hover/selection

== Seat Selection Pricing ==
Customer -> Canvas: Select seat in premium area
Canvas -> UI: onSeatClick(seatId, available=true)
UI -> UI: addSeatToCart(seatId)

UI -> PricingService: calculateSeatPrice(seatId, areaId)
PricingService -> DB: Query area base price
PricingService -> PricingService: Apply time-based discounts
PricingService -> PricingService: Apply quantity discounts
PricingService -> PricingService: Calculate fees & taxes

Note right of PricingService
  Pricing factors:
  - Base area price
  - Early bird discounts
  - Group discounts
  - Service fees
  - Platform fees
  - Taxes
end note

PricingService --> UI: Final seat price
UI -> UI: updateCartTotal()

== Multi-Seat Selection ==
loop Customer selects multiple seats
    Customer -> Canvas: Select additional seat
    Canvas -> UI: onSeatClick(nextSeatId, available=true)
    UI -> PricingService: calculateSeatPrice(nextSeatId, areaId)
    
    alt Quantity discount applies
        PricingService -> PricingService: applyGroupDiscount(seatCount)
        PricingService -> UI: Recalculate all seat prices
        UI -> UI: updateAllSeatPrices()
    else No group discount
        UI -> UI: addSeatPrice()
    end
    
    UI -> UI: updateCartSummary()
end

== Price Breakdown Display ==
UI -> Customer: Show detailed breakdown

Note left of Customer
  Price Breakdown:
  ├─ Subtotal: $120.00
  ├─ Early Bird: -$20.00
  ├─ Group Discount: -$10.00
  ├─ Service Fee: $8.00
  ├─ Platform Fee: $5.00
  └─ Total: $103.00
end note

== Dynamic Price Updates ==
DB -> PricingService: Price change event (demand spike)
PricingService -> UI: broadcastPriceUpdate(eventId)
UI -> UI: refreshPricing()
UI -> Customer: Show price update notification

@enduml

@startuml accessibility-mobile-support
!theme plain
title Accessibility & Mobile Support

actor Customer
participant "Mobile Browser" as Mobile
participant "Canvas Component" as Canvas
participant "Touch Handlers" as Touch
participant "Accessibility Layer" as A11y
participant "Screen Reader" as ScreenReader
participant "Keyboard Navigation" as Keyboard

== Mobile Initialization ==
Customer -> Mobile: Open event on mobile device
Mobile -> Canvas: Load with mobile viewport
Canvas -> Canvas: detectMobileDevice()
Canvas -> Canvas: applyMobileOptimizations()

Note right of Canvas
  Mobile optimizations:
  - Larger touch targets (min 44px)
  - Simplified pan/zoom gestures
  - Reduced visual complexity
  - Performance optimizations
end note

== Touch Interactions ==
Customer -> Mobile: Pinch to zoom
Mobile -> Touch: handleTouchStart/Move/End()
Touch -> Canvas: translateToZoomAction()
Canvas -> Canvas: updateZoomWithCenter()

Customer -> Mobile: Two-finger pan
Mobile -> Touch: handlePanGesture()
Touch -> Canvas: updatePanPosition()

Customer -> Mobile: Tap seat
Mobile -> Touch: handleSeatTouch()
Touch -> Canvas: onSeatClick() with touch context
Canvas -> Canvas: provideTactileFeedback()

== Accessibility Features ==
Customer -> A11y: Enable screen reader
A11y -> ScreenReader: Announce seat map loaded

Customer -> Keyboard: Tab navigation
Keyboard -> A11y: focusNextSeat()
A11y -> Canvas: highlightFocusedSeat()
A11y -> ScreenReader: "Seat A1, Row A, Premium section, Available, $50"

Customer -> Keyboard: Enter/Space to select
Keyboard -> Canvas: onSeatClick() via keyboard
Canvas -> A11y: announceSelection()
A11y -> ScreenReader: "Seat A1 selected, added to cart"

Customer -> Keyboard: Arrow keys to navigate
Keyboard -> A11y: navigateByDirection()
A11y -> Canvas: moveFocusToAdjacentSeat()

== Screen Reader Support ==
A11y -> ScreenReader: Describe overall layout

Note left of ScreenReader
  Screen reader announcements:
  "Seat map for Concert Event
   3 seating areas available
   Premium: 50 seats, $75 each
   Standard: 200 seats, $50 each  
   Economy: 100 seats, $25 each
   Use arrow keys to navigate seats"
end note

loop Seat navigation
    Customer -> Keyboard: Arrow key navigation
    A11y -> ScreenReader: "Moving to seat B2, Standard section"
    A11y -> ScreenReader: Announce availability and price
end

== Alternative Text Interface ==
alt Customer prefers non-visual interface
    Customer -> A11y: Request list view
    A11y -> Canvas: switchToListMode()
    Canvas -> Customer: Show tabular seat selection
    
    Note right of Canvas
      List view features:
      - Filterable by area/price
      - Sortable by seat number
      - Bulk selection options
      - Clear availability indicators
    end note
end

== Mobile Performance ==
Canvas -> Canvas: implementVirtualization()
Note right of Canvas
  Performance optimizations:
  - Virtual rendering for large venues
  - Simplified shapes on zoom out
  - Debounced touch events
  - Memory management for complex seat maps
end note

== High Contrast Mode ==
Customer -> A11y: Enable high contrast
A11y -> Canvas: applyHighContrastColors()
Canvas -> Canvas: updateSeatColorScheme()

Note right of Canvas
  High contrast colors:
  - Available: High contrast green
  - Sold: High contrast red
  - Selected: High contrast blue
  - Focused: Bold outline with pattern
end note

@enduml

@startuml error-handling-edge-cases
!theme plain
title Error Handling & Edge Cases

actor Customer
participant "Canvas Component" as Canvas
participant "Error Boundary" as ErrorBoundary
participant "UI Component" as UI
participant "Retry Logic" as Retry
participant "Fallback UI" as Fallback
participant "Error Service" as ErrorService
participant "Analytics" as Analytics

== Seat Map Loading Errors ==
Customer -> UI: Load event page
UI -> Canvas: Load seat map data

alt Seat map not found
    Canvas -> ErrorBoundary: throw SeatMapNotFoundError
    ErrorBoundary -> Fallback: Show fallback UI
    Fallback -> Customer: "Seat map temporarily unavailable - showing list view"
    Fallback -> UI: switchToListMode()
else Seat map corrupted
    Canvas -> ErrorBoundary: throw SeatMapCorruptedError
    ErrorBoundary -> ErrorService: logError(error, context)
    ErrorBoundary -> Fallback: Show simplified seat selection
end

== Network Connection Issues ==
Canvas -> Canvas: detectNetworkFailure()
Canvas -> Retry: attemptReconnection()

loop Retry attempts (max 3)
    Retry -> Canvas: retryLoadSeatMap()
    alt Retry successful
        Canvas -> Customer: Resume normal operation
    else Retry failed
        Retry -> Retry: incrementAttemptCount()
    end
end

alt All retries failed
    Canvas -> Fallback: showOfflineMode()
    Fallback -> Customer: "You're offline - seat selection limited"
end

== Seat Selection Race Conditions ==
Customer -> Canvas: Select seat rapidly
Canvas -> UI: onSeatClick(seatA1)
Canvas -> UI: onSeatClick(seatA1) [duplicate]

UI -> UI: debounceSelection()
UI -> UI: preventDuplicateSelection()

alt Seat already in processing
    UI -> Customer: Show "Processing..." state
else Seat selection valid
    UI -> UI: processSelection()
end

== Memory Management ==
Canvas -> Canvas: monitorMemoryUsage()

alt Large venue (>10k seats)
    Canvas -> Canvas: enableVirtualization()
    Canvas -> Canvas: implementLazyLoading()
    Note right of Canvas: Only render visible seats
else Memory pressure detected
    Canvas -> Canvas: reduceRenderQuality()
    Canvas -> Canvas: clearUnusedAssets()
end

== Browser Compatibility ==
Canvas -> Canvas: detectBrowserCapabilities()

alt WebGL not supported
    Canvas -> Canvas: fallbackToCanvas2D()
    Canvas -> Customer: Show performance warning
else Touch events not supported
    Canvas -> Canvas: enableMouseOnlyMode()
end

== Invalid User Actions ==
Customer -> Canvas: Try to select sold seat
Canvas -> Canvas: validateSeatSelection()
Canvas -> Customer: toast.error("This seat is no longer available")
Canvas -> Analytics: trackInvalidSelection()

Customer -> Canvas: Select seats across different events
Canvas -> Canvas: detectCrossEventSelection()
Canvas -> Customer: "Please select seats from the same event"

== Session Timeout ==
Canvas -> Canvas: detectSessionExpiry()
Canvas -> Customer: "Your session has expired"
Canvas -> UI: redirectToLogin()

== Performance Degradation ==
Canvas -> Canvas: monitorPerformance()

alt Rendering too slow (>16ms)
    Canvas -> Canvas: reduceSeatMapComplexity()
    Canvas -> Canvas: enablePerformanceMode()
    Note right of Canvas
      Performance mode:
      - Simplified seat shapes
      - Reduced animations
      - Lower render frequency
    end note
end

== Data Inconsistency ==
Canvas -> Canvas: validateSeatMapData()

alt Seating structure mismatch
    Canvas -> ErrorService: reportDataInconsistency()
    Canvas -> Fallback: showBasicSeatGrid()
    Canvas -> Customer: "Simplified view - some features limited"
else Price data missing
    Canvas -> UI: requestPriceRefresh()
    Canvas -> Customer: "Loading pricing information..."
end

== Graceful Degradation ==
ErrorBoundary -> Fallback: determineUserCapabilities()

Note right of Fallback
  Fallback strategies:
  1. Canvas → Static image with clickable areas
  2. Static image → Simple list view
  3. List view → Text-only selection
  4. Text-only → Contact support
end note

Fallback -> Customer: "Choose your preferred seat selection method"
Fallback -> Analytics: trackFallbackUsage()

@enduml
  3. List view → Text-only selection
  4. Text-only → Contact support
end note

Fallback -> Customer: "Choose your preferred seat selection method"
Fallback -> Analytics: trackFallbackUsage()

@enduml
